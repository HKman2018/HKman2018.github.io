[{"categories":["TicTacToe"],"contents":"#Tic Tac Toe 思路\n如何code tic tac toe game 首先要如何取得O同X的value:  我們在html寫一個div,裡面class為box 之後box裡面有9個細box,給於value ==\u0026gt;data-col=\u0026quot;\u0026quot; ``` \u0026lt;div class=\u0026quot; box\u0026quot;\u0026gt; \u0026lt;div data-col=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div data-col=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div data-col=\u0026quot;2\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div data-col=\u0026quot;3\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div data-col=\u0026quot;4\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div data-col=\u0026quot;5\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div data-col=\u0026quot;6\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div data-col=\u0026quot;7\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div data-col=\u0026quot;8\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ``` 之後在js裡面,用querySelectorAll取得細box的位置, ``` for (let grid of grids) { grid.addEventListener('click', function(e){ console.log(e.target.dataset.col) }) } ``` for loop 取得細box的value ,當知道如何取得9個細value 時 就需要想下判 O 同 x 誰在玩,用let turn=0 作為運行次數 , turn%/2 == 0 當單數是 O, X 則是雙數 ``` let turn; for (let grid of grids) { turn = 0 grid.addEventListener('click', function(e){ if (turn % 2 == 0) { e.currentTarget.innerHTML = '\u0026lt;i class=\u0026quot;far fa-circle \u0026quot;\u0026gt;\u0026lt;/i\u0026gt;'; player.o.push(e.target.dataset.col) } else { e.currentTarget.innerHTML = '\u0026lt;i class=\u0026quot;fa fa-times\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;'; player.x.push(e.target.dataset.col) } turn++ }) } ``` 知道如何取得O,X的value 便要將value儲存： ``` player = { O:[], X:[] } ``` 將已知結果載入 ``` let data = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ] ``` 之後我們便對比player 同data 的數值是一樣,如果一樣就勝出 建立function 將player 數值放進,for loop data的array 取得value ``` function checkWin(player) { for (let item of **data**) { let scoreX = 0 let scoreY = 0 for (let index in item) { let playerX = player.x[index] let playerY = player.y[index] if (item[index] == playerX) { scoreX += 1 } else if (item[index] == playerY) { scoreY += 1 } if (scoreX == \u0026quot;3\u0026quot;) { return 'x' } if (scoreY == \u0026quot;3\u0026quot;) { return 'y' } } } } ``` 當return x 時 x 便勝出  另外一種方法，以 data 思維 建立一個\u0008array data 再建立x,y 給於細box (grid.x,grid.y)   let x = 0, y = 0; i = 0; data = [[], [], []] grids = document.querySelectorAll(\u0026quot;.box\u0026quot;); turn = 0; for (let grid of grids) { grid.x = x; grid.y = y; grid.i = i++; data[y][x] = 0; x++; if (x \u0026gt; 2) { x = 0; y++; } grid.addEventListener('click', function(e){ e.currentTarget.x e.currentTarget.y }); } for loop 時 data建立了1個array 內有3個array,3個array有3個數值 分別[0,0,0] 當玩家`click`時 讀取e.vent.currentTarget.x 及e.vent.currentTarget.y 分別放入 data[e.vent.currentTarget.y][e.vent.currentTarget.x]  ","permalink":"https://hkman2018.github.io/blog/tictactoe/","tags":["TicTacToe"],"title":"TicTacToe"},{"categories":["Git 語法"],"contents":"GIT 語法 本地端  在本地端資料夾新增數據庫   git init  從遠端數據庫複製 git clone[url]   git clone https://github.com/username/Personal-website.git  查詢設定列表   git config --list  加檔案進入commit   git add *filename*  加全部檔案進入commit   git add .  查詢commit內file   git status  顯示之前紀錄   git log  記錄commit   git commit -m '訊息' 還原指令  還原工作目錄與索引，會跟最後一次 commit 保持一樣   git reset --hard  全部檔案取消索引   git reset HEAD  單一檔案取消索引   git reset HEAD *filename*  恢復單一檔案到最新 commit 狀態   git checkout *filename*  刪除最近一次 commit   git reset --hard HEAD^  上面語法如果刪除錯了可以再用此語法還原   git reset --hard ORIG_HEAD  刪除最近一次 commit，但保留異動內容   git reset --soft HEAD^  commit 後發現有幾個檔案忘了加入進去，想要補內容進去時   git commit --amend 分支  顯示所有本地分支   git branch  新增分支   git branch 分支名稱  切換分支   git checkout 分支名稱  合併指定分支到目前的分支   git merge 分支名稱  刪除分支   git branch -d 分支名稱 遠端數據庫指令  查詢遠端數據庫   git remote  將本地分支推送到遠端分支   git push 遠端數據庫名稱 遠端分支名稱  將遠端分支拉下來與本地分支進行合併   git pull  查詢遠端分支url   git remote -v  更改遠端分支url   git remote set-url origin https://github.com/username.git ","permalink":"https://hkman2018.github.io/blog/git/","tags":["Git"],"title":"Git 語法"},{"categories":["Promise"],"contents":"callback \u0026amp; promise ,async/ await function greeting(name) { alert(\u0026#39;Hello \u0026#39; + name); } function processUserInput(callback) { var name = prompt(\u0026#39;Please enter your name.\u0026#39;); callback(name); } processUserInput(greeting);  Callback \u0026amp; Promise 分別在callback可以帶走closure，而Promise .then不能帶走closure,但為何仲要用Promise,因Promise 可以避免callback hell情況 ,而且Promise可以用來將非同步的API改成「看起來同步」的用法,  callback(_) fs.readdir(file,(function(err,path){//callback function(當file執行時就會呼叫 function(err,path))  if(err){ return console.log(err); }else{ 。。。。。 再call function(..) } })) Promise() let readDirFile = function(file:string){ return new Promise(function(resolve,reject){ fs.readdir(file,((err,path)=\u0026gt;{ if(err){ return reject(err); }else{ return resolve(path) } }) }) } //call Promise function  readDirFile(file).then((value)=\u0026gt;{ 再call function(value){...} }).catch((err)=\u0026gt;{//Promise 如果err就會直接去到最近的catch(err)  console.log(err) })  Promise 每次只會回傳一個值:resolve or reject:  return resolve(value) //resolve 不等於return  or return reject(error) ","permalink":"https://hkman2018.github.io/blog/promise/","tags":["Promise"],"title":"Promise"},{"categories":["notes"],"contents":"Notes  Add SSH key ssh-keygen cat .ssh/id_rsa.pub 取得ssh key 加入gitlab function function(可有參數或無參數){ return 值 } function addSum(){ let sum = 0 //當執行return function時也給於 sum return 的數值,  //再執行時sum的值是上次return的值\u0026lt;br\u0026gt;  return (num)=\u0026gt;{ sum = sum +num return sum } } const add = addSum()// closure 的addSum現時值為0 console.log(add(3))//值 3 console.log(add(3))//值 6 \u0008  instanceof Object or Array function print() { let final = \u0026#34;\u0026#34;; for (let key in hk) { let value = hk[key] final += key + \u0026#34;: \u0026#34;; if (value instanceof Array) { for (let item of value) { if (item instanceof Object) { final = final + \u0026#34;\\n\u0026#34;; for (let key2 in item) { let value2 = item[key2]; final = final + key + \u0026#34;_\u0026#34; + key2 + \u0026#34;: \u0026#34; + value2 + \u0026#34;\\n\u0026#34; } } else final += item + \u0026#34; 你好\u0026#34;; } } else if (value instanceof Object) { final = final + \u0026#34;\\n\u0026#34;; for (let key2 in value) { let value2 = value[key2]; final = final + key + \u0026#34;_\u0026#34; + key2 + \u0026#34;: \u0026#34; + value2 + \u0026#34;\\n\u0026#34; } } else final += value final += \u0026#34;\\n\u0026#34;; } return final; } console.log(print())  check string string 不能改變 Json.stringify(obj)==Json.stringify(obj2) ===\u0026gt;true  class interface and abstract 1.interface的方法全都是抽象方法 abstract則有一般方法和抽象方法 抽象方法指的是沒有「實作」出來的方法 2. interface與abstract類別都不能直接用來建立物件實體， 必須由一個標準類別來繼承它，實作其抽象方法， 然後再以此建立物件實體。 3. interface可多重繼承interface abstract只能單一繼承 4. interface沒有建構子 abstract有建構子 5. interface沒有內建的super與this變數 abstract有內建的super與this變數 6. interface的成員變數全都是static final型式 abstract類別的成員變數比照一般類別 7. interface內的方法只可封裝public、default abstract內的方法只可封裝public、default、protected 8. 需要使用迂迴的方式去找出實體類別間的對應關係， 所以與抽象類別的速度相比之下較為緩慢   response 同一個route 不能用兩次response 所以用return 出去 can not find header 可以用return解決 const authPass = (req,res,next:express.NextFunction)=\u0026gt;{ if(req,session[\u0026#39;user\u0026#39;]){ next() }else{ res.redirect(\u0026#39;/\u0026#39;) } } login authPass 一定要擺係public之後 或者 用app.use(\u0026#39;/login\u0026#39;, express.static(\u0026#39;/userFile\u0026#39;)) async function getApples(){ const res = await fetch(\u0026#39;/apple\u0026#39;) //server -\u0026gt;Internet -\u0026gt; client  //Object -\u0026gt; string -\u0026gt; object  //呢度嘅res.json與server 的res.json()巧用正好相反  const apples = res.json()//string-\u0026gt;object } async createApple(){ const apple ={ weight:300, price:200 } //browser send Async request 嘅function  //1 send 去咩 route  //2 Http method  //3 headers \u0026amp; body  const res = await fetch(\u0026#39;/apple\u0026#39;,{ method:\u0026#34;POST\u0026#34;, headers:{ \u0026#34;Content-Type\u0026#34;:\u0026#34;application/json\u0026#34; }, body:JSON.stringify(apple) }) if(res.status ===200){ //將response body 由text 轉返 Javascript Object  const result = await res.json()//string -\u0026gt;object  console.log(result) }else(res.status === 400){ //status 400係唔會炒左個promise  } }  上傳image 留意地方  要留意上傳時如果 ' ' 便會出現error 需要判是否有value  in server const data ={ value:req.body.text, image:\u0026#39;\u0026#39; } if(req.file){ data.image =req.file.filename } in javascript const formData = new FormData(); formData.append(\u0026#39;content\u0026#39;,form.content.value); formData.append(\u0026#39;image\u0026#39;,form.image.files[0]); const res = await fetch(\u0026#39;/memos\u0026#39;,{ method:\u0026#34;POST\u0026#34;, body:formData //已打包成JSON 不需要json.stringify()  });  FormData 可以用來收集表單資訊，如果有個 form 代表著 標籤的 DOM，可以直接作為 FormData 建構之用  let formData = new FormData(form); 使用 XMLHttpRequest 來進行 POST，呼叫 send 方法時，可以將 FormData 實例當成引數傳入，這時請求的 Content-Type一定是 multipart/form-data，無需也不能自行設置請求標頭 Content-Type。\n如果只是使用 FormData 作為一種表單序列化時的簡便 API，伺服端必須能處理 multipart/form-data內容，而不是單純透過請求參數的 API 來取得相關請求參數。\n如果表單中有 type = \u0026ldquo;file\u0026rdquo; 的 input 標籤，當表單 DOM 物件被當成 FormData 建構時的引數，可以直接進行檔案上傳，如果是使用 append 方法，加入 type = \u0026ldquo;file\u0026rdquo; 的 input 標籤選取之檔案，例如只選取一個檔案的情況，可以如下撰寫\nlet photo = document.getElementById(\u0026#39;photo\u0026#39;); let formData = new FormData(); formData.append(\u0026#39;photo\u0026#39;, photo.files[0]);  HTML Form Submission in .html\n\u0026lt;form action=\u0026#34;/contact\u0026#34;method=\u0026#34;post\u0026#34;\u0026gt; ... ... \u0026lt;/form\u0026gt; in server\n... app.use(express.urlencoded({extended:true})) ... ... //route handlers //app 的method 必須同form的method 一樣,而且url path也必須一樣 app.post(\u0026#39;/contact\u0026#39;,((req,res)=\u0026gt;{ console.log(req.body) }) Multipart Form (with files) in .html\n\u0026lt;form action=\u0026#34;/contact\u0026#34;method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form\u0026#34;\u0026gt; ... \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;profile\u0026#34;\u0026gt; ... \u0026lt;/form\u0026gt; in server\ninstall multer const storage = multer.diskStorage({ destination: function (req, file, cb) { cb(null, path.resolve(\u0026#39;./public/uploads\u0026#39;)); }, filename: function (req, file, cb) { cb(null, `${file.fieldname}-${Date.now()}.${file.mimetype.split(\u0026#39;/\u0026#39;)[1]}`); } }) const upload = multer({ storage }) app.post(\u0026#39;/contact\u0026#39;, upload.single(\u0026#39;profile\u0026#39;),(req, res)=\u0026gt;{ console.log(res.body) if(req.file){ data.image = req.file.filename } }) data set \u0026lt;div class=\u0026#34;edit-form\u0026#34;data-index= \u0026#34;${index}\u0026#34;\u0026gt; ... ... \u0026lt;/div\u0026gt; in javascript button.addEventListener(\u0026#39;click\u0026#39;,(event)=\u0026gt;{ let index = event.currentTarget.getAttribute(\u0026#39;data-index\u0026#39;) }) ","permalink":"https://hkman2018.github.io/blog/teckycademy/","tags":["notes"],"title":" notes"},{"categories":["CSS"],"contents":"box-sizing  \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .container{ box-sizing:content-box; width:100%; } \u0026lt;/style\u0026gt;  \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .container{ box-sizing:content-box; width:100%; border: solid #5B6DCD 10px; padding: 5px } \u0026lt;/style\u0026gt;  \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .container{ box-sizing: border-box; width: 100%; border: solid #5B6DCD 10px; padding: 5px; } \u0026lt;/style\u0026gt; @font-face { font-family: myFirstFont; src: url(sansation_light.woff); } div { font-family: myFirstFont; } ","permalink":"https://hkman2018.github.io/blog/css/","tags":["CSS"],"title":"CSS"},{"categories":["Markdown語法"],"contents":" 標題大小  H1 # H2 ## H3 ### H4 #### H5 ##### H6 ######   粗體字及斜體 斜體再文字前後加一個星星\n 例～＊斜體＊斜體\n 粗體字再文字前後加兩個星星\n 例～＊＊斜體＊＊ 斜體\n  連結網站  [呈現的文字] (你的網址)\n  連結圖片  ! [] (你的圖片網址or你的圖片路徑)\n   List item List item List item List item List item   List item List item List item List item List item   code 呈現  如果想顯示code ,前後加三個頓號、、、 前面頓號後加程式站言,例如、、、java var a = 1+1 、、、\n var s = \u0026#34;JavaScript syntax highlighting\u0026#34;; alert(s); s = \u0026#34;Python syntax highlighting\u0026#34; print s  \u0008markdown 影片介紹   ","permalink":"https://hkman2018.github.io/blog/markdown/","tags":["Markdown"],"title":"Markdown 語法"},{"categories":["socket io"],"contents":"socket.io   安裝socket  npm install socket.io //如typescript加埋 @types/socket.io  import socket.io   import express from 'express'; import expressSession from 'express-session'; import http from 'http'; import {Server as SocketIO} from 'socket.io'; const app = express(); const server = new http.Server(app); const io = new SocketIO(server); const sessionMiddleware = expressSession({ secret: 'hongkonger is good', resave:true, saveUninitialized:true }); const Middleware = expressSession({ secret: 'Memo wall is fun', resave:true, saveUninitialized:true }); app.use(Middleware); io.use((socket,next)=\u0026gt;{ const request = socket.request as express.Request; Middleware(request,request.res as express.Response,next as express.NextFunction); }) io.on('connection', function (socket) { //每次socket connect 執行一次 const user:User | undefined = (socket.request as express.Request).session['user']; if(user){ socket.join(`user-${user.username}`); } socket.emit('new-memo',memo); });   in html \u0026lt;script src=\u0026quot;/socket.io/socket.io.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  // 連接咗嘅Socket.IO socket const socket = io.connect(); // loadMemo socket.on('new-memo',async function(data){ await loadMemos(); }) ","permalink":"https://hkman2018.github.io/blog/socketio/","tags":["socket io"],"title":"socket io"},{"categories":["SQL"],"contents":"SQL 基礎語法  psql -h localhost     權限 內容     SELECT 能使用SELECT命令來取得資料   INSERT 能使用INSERT命令來插入資料   UPDATE 能使用UPDATE命令來插入資料   DELETE 能使用DELETE命令來插入資料   EXECUTE 執行程序   REFERENCES 可以用外來鍵參考資料   ALL 所有權限    ###常用 SQL\n app.get('/',(req,res)=\u0026gt;{ const content = client.query(`SELECT * FROM memos order by updated_at desc`) //以updated時間排序 })  app.post('/',(req,res)=\u0026gt;{ const content = client.query(`INSERT INTO memos(content, image, created_at, updated_at) VALUES ($1, $2, NOW(), NOW()) RETURNING id`) //新增post之後return 返id })  app.put('/:id',(req,res)=\u0026gt;{ const content = client.query(`UPDATE memos SET content= $1,image=$2 where id=$3;`, [req.body.textareaValue, req.file.filename, id]) //更新post })  app.delete('/:id',(req,res)=\u0026gt;{ const content = client.query(`DELETE from memos where id = $1`,[id]) //更新post }) ","permalink":"https://hkman2018.github.io/blog/sql/","tags":["SQL"],"title":"SQL"}]